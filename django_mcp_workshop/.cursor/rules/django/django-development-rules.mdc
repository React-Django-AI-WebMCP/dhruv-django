---
alwaysApply: true
description: "Django development best practices including ORM optimization, RESTful API design, authentication, testing, and performance guidelines"
---

# Django Development Best Practices and Coding Standards

You are an expert in Python, Django, and scalable RESTful API development. This document contains all rules and guidelines for ongoing development work.

## Core Principles

- **Django-First Approach**: Use Django's built-in features and tools wherever possible to leverage its full capabilities
- **Code Quality**: Prioritize readability and maintainability; follow Django's coding style guide (PEP 8 compliance)
- **Naming Conventions**: Use descriptive variable and function names; adhere to naming conventions (lowercase with underscores for functions and variables)
- **Modular Architecture**: Structure your project in a modular way using Django apps to promote reusability and separation of concerns
- **Performance Awareness**: Always consider scalability and performance implications in your design decisions

## Coding Conventions

### Python Style Guide

- Follow PEP 8 style guide
- Use Black for code formatting (line length: 120)
- Use type hints for function parameters and return types
- Write comprehensive docstrings for all classes and functions
- Use descriptive variable and function names
- Avoid abbreviations unless they're widely understood

### Django Naming Conventions

- **Models**: PascalCase (e.g., `UserProfile`)
- **Views**: snake_case (e.g., `user_list_view`)
- **URLs**: kebab-case in URLs, snake_case in Python (e.g., `/api/users/`, `user_list_view`)
- **Serializers**: PascalCase with "Serializer" suffix (e.g., `UserSerializer`)
- **Managers**: PascalCase with "Manager" suffix (e.g., `ActiveUserManager`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_FILE_SIZE`)

## Views and API Design

### Class-Based Views

- **Always use Class-Based Views**: Leverage Django's class-based views (CBVs) with DRF's APIViews
- **Use appropriate mixins**: DRF provides many useful mixins (ListModelMixin, CreateModelMixin, etc.)
- **Keep views light**: Focus views on request handling; keep business logic in models, managers, and services
- **Use ViewSets when appropriate**: For CRUD operations, use ViewSets instead of individual views

### RESTful Design

- **Follow RESTful principles**: Use proper HTTP methods (GET, POST, PUT, PATCH, DELETE)
- **Use appropriate status codes**: 200 (OK), 201 (Created), 204 (No Content), 400 (Bad Request), 401 (Unauthorized), 403 (Forbidden), 404 (Not Found), 422 (Unprocessable Entity), 500 (Internal Server Error)
- **Consistent response format**: Use unified response structure from `core.responses.APIResponse` for both success and error cases
- **Resource naming**: Use plural nouns for resources (e.g., `/api/users/`, not `/api/user/`)

### API Response Format

**Success Response:**
```json
{
    "success": true,
    "message": "Success message",
    "data": { ... }
}
```

**Error Response:**
```json
{
    "success": false,
    "message": "Error message",
    "errors": {
        "field_name": ["Error details"]
    },
    "error_code": "ERROR_CODE"
}
```

## Models and Database

### ORM Best Practices

- **ORM First**: Leverage Django's ORM for database interactions; avoid raw SQL queries unless necessary for performance
- **Business Logic in Models**: Keep business logic in models and custom managers, not in views
- **Use Model Methods**: Create methods on models for business logic operations
- **Use Model Properties**: Use `@property` decorator for computed fields

### Query Optimization

- **N+1 Problem Prevention**: Always use `select_related()` for ForeignKey and OneToOneField relationships
- **Use prefetch_related()**: For ManyToManyField and reverse ForeignKey relationships
- **Query Monitoring**: Monitor query counts and execution time in development using django-debug-toolbar
- **Database Indexing**: Implement proper database indexing for frequently queried fields using `db_index=True` or `Meta.indexes`
- **Use only() and defer()**: When you only need specific fields, use `only()` or `defer()` to reduce data transfer
- **Avoid queryset evaluation in loops**: Evaluate querysets once and reuse the results

### Transactions

- **Use transaction.atomic()**: For data consistency in critical operations
- **Nested transactions**: Be aware of how nested transactions work
- **Database-level constraints**: Use database-level constraints (unique_together, db_constraints) when possible

### Model Design

- **Abstract Base Models**: Use abstract base models for common fields (created_at, updated_at)
- **Custom Managers**: Create custom managers for common queries
- **Model Validation**: Use `clean()` method for model-level validation
- **Signal Usage**: Use Django signals sparingly and document their purpose

## Serializers and Validation

### DRF Serializers

- **Use DRF Serializers**: Always use Django REST Framework serializers for data validation and serialization
- **Field Validation**: Use serializer field validation for input sanitization
- **Custom Validation**: Implement `validate_<field>()` methods for field-level validation
- **Object-level Validation**: Use `validate()` method for cross-field validation
- **Nested Serializers**: Properly handle nested relationships with appropriate serializers

### Validation Best Practices

- **Validate Early**: Validate data as early as possible in the request lifecycle
- **Custom Validators**: Create reusable validators in `core.validators` for common validation patterns
- **Error Messages**: Provide clear, user-friendly error messages
- **Field Requirements**: Use `required=True/False` appropriately
- **Read-only Fields**: Mark fields as `read_only=True` when they shouldn't be modified by users

## Authentication and Permissions

### JWT Authentication

- **Use djangorestframework-simplejwt**: For JWT token-based authentication
- **Token Refresh**: Implement automatic token refresh mechanism
- **Token Blacklisting**: Use token blacklisting for logout functionality
- **Secure Token Storage**: Store tokens securely on the client side

### Permission Classes

- **Custom Permissions**: Implement granular permission classes in `core.permissions` for different user roles
- **Permission Hierarchy**: Create a clear permission hierarchy
- **Object-level Permissions**: Use `has_object_permission()` for object-level access control
- **Role-Based Access Control**: Implement RBAC for complex permission requirements

### Security Best Practices

- **CSRF Protection**: Implement proper CSRF protection for state-changing operations
- **CORS Configuration**: Configure CORS properly for your frontend domains
- **Input Sanitization**: Always sanitize and validate user input
- **SQL Injection Prevention**: Use ORM queries instead of raw SQL
- **XSS Prevention**: Escape user-generated content
- **Rate Limiting**: Implement rate limiting for API endpoints
- **Password Security**: Use strong password requirements and hashing

## URL Configuration

### URL Patterns

- **Clean URL Patterns**: Use `urlpatterns` to define clean URL patterns with each `path()` mapping routes to views
- **Nested Routing**: Use `include()` for modular URL organization
- **URL Naming**: Use descriptive names for URL patterns
- **Trailing Slashes**: Be consistent with trailing slashes

### URL Organization

- **App-level URLs**: Create `urls.py` in each app's `urls/` folder
- **Main URL Configuration**: Include app URLs directly in main `config/urls.py`
- **Direct Routing**: Apps can be included directly: `path("api/calendar/", include("apps.calendar.urls"))`

## Error Handling

### Exception Handling

- **Custom Exception Handler**: Use global exception handler in `core.exceptions.custom_exception_handler` for consistent error responses
- **Custom Exceptions**: Create custom exceptions in `core.exceptions` for application-specific errors
- **Proper HTTP Status Codes**: Use appropriate HTTP status codes (400, 401, 403, 404, 422, 500, etc.)
- **Error Logging**: Log errors appropriately with context information
- **User-Friendly Messages**: Provide user-friendly error messages while logging detailed information

### Error Response Format

Always use the standardized error response format:
```json
{
    "success": false,
    "message": "Error description",
    "errors": {
        "field_name": ["Specific error details"]
    },
    "error_code": "SPECIFIC_ERROR_CODE"
}
```

## Testing Guidelines

### Test Structure

- **Test Organization**: Organize tests in `tests/` folder within each app
- **Test Files**: Create separate test files for models, views, serializers (`test_models.py`, `test_views.py`, `test_serializers.py`)
- **Test Factories**: Use factory-boy for creating test data (create factories in `tests/factories.py`)
- **Test Coverage**: Aim for minimum 80% code coverage

### Testing Best Practices

- **Unit Tests**: Write unit tests for models, serializers, and utility functions
- **Integration Tests**: Write integration tests for API endpoints
- **Test Isolation**: Ensure tests are isolated and don't depend on each other
- **Use Fixtures**: Use pytest fixtures for common test setup
- **Mock External Services**: Mock external API calls and services
- **Test Edge Cases**: Test edge cases and error conditions
- **Test Performance**: Write performance tests for critical paths

### Test Naming

- **Test Functions**: Use descriptive names starting with `test_`
- **Test Classes**: Use descriptive class names ending with `Test`
- **Test Organization**: Group related tests in test classes

## Logging

### Logging Strategy

- **Structured Logging**: Use structured logging with JSON formatter for production
- **Request/Response Logging**: Log API calls with execution time, user info, and response status
- **Performance Monitoring**: Log slow queries and performance bottlenecks
- **Error Logging**: Log errors with full context (stack trace, request data, user info)
- **Log Levels**: Use appropriate log levels (DEBUG, INFO, WARNING, ERROR, CRITICAL)

### When to Log

- **API Requests**: Log all API requests (handled by middleware)
- **Business Logic**: Log important business logic operations
- **Errors**: Always log errors with context
- **Performance**: Log slow operations (>1 second)
- **Security Events**: Log authentication failures, permission denials

## Performance Optimization

### Query Optimization

- **Use select_related()**: For ForeignKey and OneToOneField relationships
- **Use prefetch_related()**: For ManyToManyField and reverse ForeignKey relationships
- **Avoid N+1 Queries**: Always check for N+1 query problems
- **Use only() and defer()**: When you only need specific fields
- **Database Indexing**: Add indexes for frequently queried fields
- **Query Analysis**: Use `explain()` to analyze query performance

### Caching Strategy

- **Cache Frequently Accessed Data**: Use Django's cache framework for frequently accessed data
- **Cache Keys**: Use namespaced cache keys
- **Cache Invalidation**: Implement proper cache invalidation strategies
- **Cache Timeouts**: Set appropriate cache timeouts based on data freshness requirements

### Response Optimization

- **Pagination**: Always paginate list endpoints
- **Field Selection**: Allow clients to specify required fields to reduce payload size
- **Compression**: Enable response compression for large payloads
- **Lazy Loading**: Use lazy loading for related objects when appropriate

## Code Review Checklist

Before submitting code for review, ensure:

- [ ] Code follows the project's style guidelines
- [ ] All tests pass
- [ ] New code is covered by tests
- [ ] Documentation is updated if needed
- [ ] No security vulnerabilities introduced
- [ ] Performance considerations addressed
- [ ] Error handling is appropriate
- [ ] Logging is added where necessary
- [ ] Code is properly formatted (Black, isort)
- [ ] No linting errors
- [ ] Type hints are added where appropriate
- [ ] Docstrings are comprehensive
- [ ] No hardcoded values (use constants or settings)
- [ ] Database queries are optimized
- [ ] No N+1 query problems
- [ ] Proper use of transactions
- [ ] Security best practices followed

## Common Pitfalls and How to Avoid Them

### N+1 Query Problem

**Problem**: Making multiple database queries in a loop
**Solution**: Use `select_related()` or `prefetch_related()`

### Missing Transactions

**Problem**: Data inconsistency in multi-step operations
**Solution**: Use `transaction.atomic()` decorator or context manager

### Hardcoded Values

**Problem**: Magic numbers and strings scattered throughout code
**Solution**: Use constants in `core.constants` or settings

### Business Logic in Views

**Problem**: Views contain complex business logic
**Solution**: Move business logic to models, managers, or service classes

### Missing Error Handling

**Problem**: Unhandled exceptions causing 500 errors
**Solution**: Use try-except blocks and custom exception handlers

### Inefficient Queries

**Problem**: Fetching unnecessary data from database
**Solution**: Use `only()`, `defer()`, and proper `select_related()`/`prefetch_related()`

### Missing Logging

**Problem**: Difficult to debug issues in production
**Solution**: Add appropriate logging at key points in the code

### Security Issues

**Problem**: Vulnerable to common attacks (SQL injection, XSS, etc.)
**Solution**: Always use ORM queries, escape user input, implement proper authentication/authorization

## Best Practices Summary

1. **Always use type hints** for function parameters and return types
2. **Write comprehensive docstrings** for all classes and functions
3. **Use constants** from `core.constants` instead of hardcoded values
4. **Optimize database queries** - always check for N+1 problems
5. **Handle errors properly** - use custom exception handlers
6. **Log appropriately** - add logging for important operations
7. **Write tests** - aim for high test coverage
8. **Follow RESTful principles** - use proper HTTP methods and status codes
9. **Keep views light** - move business logic to models/services
10. **Use transactions** - for data consistency in multi-step operations
